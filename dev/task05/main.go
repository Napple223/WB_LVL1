package main

import (
	"context"
	"fmt"
	"math/rand"
	"time"
)

//Разработать программу, которая будет последовательно
//отправлять значения в канал, а с другой стороны
//канала — читать.
//По истечению N секунд программа должна завершаться.

//Для решения данной задачи предлагаю использовать
//контекст с таймаутом (фактически контекст с дедлайном).
//Удобное решение из "коробки", которое позволит оповестить все горутины
//о необходимости завершения работы программы.

const (
	//Время работы программы в секундах
	timeout time.Duration = 3 * time.Second
)

func main() {
	ctx, cancel := context.WithTimeout(context.Background(), timeout)
	defer cancel()
	start := time.Now()
	//Создаем канал для передачи данных.
	data := make(chan int)
	//Рандомизируем рандом.
	rand.NewSource(time.Now().UnixNano())
	//Горутина для записи данных в канал.
	go func(ctx context.Context, data chan<- int) {
		//Тикер, задающий периодичность отправки данных в канал.
		tik := time.NewTicker(500 * time.Millisecond)
		for {
			select {
			//По истечению времени заканчиваем работу горутины.
			case <-ctx.Done():
				//Останавливаем тикер.
				tik.Stop()
				return
			case <-tik.C:
				//Отправляем случайное число в канал.
				data <- rand.Intn(1000)
			}
		}
	}(ctx, data)

	loop := true
	//В основном потоке читаем данные из канала.
	for loop {
		select {
		//Ждем сигнала для завершения работы программы.
		case <-ctx.Done():
			loop = false
		case d := <-data:
			fmt.Printf("Получены данные:%d\n", d)
		}
	}
	//Закрываем канал.
	close(data)
	//Следует отметить, что фактическое время работы программы
	//будет незначительно больше, чем N секунд.
	fmt.Printf("Программа завершила работу по истечению %v.", time.Since(start))
}
