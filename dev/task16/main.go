package main

import (
	"fmt"
	"sort"
)

// Реализовать быструю сортировку массива (quicksort)
// встроенными методами языка.

//Одна из самых быстрых сортировок.
//Средняя сложность О(logn), для худшего случая О(n^2)
//Сложность в основном зависит от выбора опорного элемента.
//Т.е. худшим случаем является выбор в качестве опорногоэ
//элемента наибольшего или наименьшего числа массива.

func quickSort(input []int) {
	//Если длина массива == 1,
	//заканчиваем сортировку.
	if len(input) == 1 {
		return
	}

	//Выбираем рандомный опорный элемент.
	pivotIdx := len(input) / 2
	maxIdx := len(input) - 1
	//Для удобства меняем опорный и последний элемент массива.
	input[pivotIdx], input[maxIdx] = input[maxIdx], input[pivotIdx]
	//Указатель на последнее число, которое > опорного элемента.
	var left int
	//Проходим циклом по всем элементам массива кроме последнего.
	for i := 0; i < maxIdx; i++ {
		//Если число меньше опорного (равно необходимо чтобы
		//сортировать массивы с повторяющимися числами),
		//то меняем его с заведомо большим числом.
		//и инкрементируем границу.
		if input[i] <= input[maxIdx] {
			input[i], input[left] = input[left], input[i]
			left++
		}
	}
	//Меняем опорный элемент с заведомо большим числом.
	input[left], input[maxIdx] = input[maxIdx], input[left]

	//рекурсивно вызываем сортировку для левой и правой части
	//массива от опорного элемента.
	quickSort(input[:left])
	quickSort(input[left:])
}

func main() {
	arr := []int{5, 4, 1, 2, 0, 8, 55, 32, 12, 23, 12}
	quickSort(arr)
	fmt.Println(sort.IntsAreSorted(arr))
}
