package main

import (
	"log"
	"os"
)

//К каким негативным последствиям может привести
//данный фрагмент кода, и как это исправить?
//Приведите корректный пример реализации.

//К глобальным переменным можно обращаться
//из любой функции, поэтому их изменение
//может быть неожиданным.
//+ такое решение тяжело отлаживается.
//var justString string

//func someFunc() {
//Хранить в памяти очень большую строку
//нерационально, т.к. она может не
//поместиться в памяти и, как минимум,
//замедлит программу.
//	v := createHugeString(1 << 10)
//Строки в го иммутабельны, т.е. при их
//изменении мы создаем новую строку,
//занимающую доп. память.
//	justString = v[:100]
//}

//Мой вариант реализации.

// Избавляемся от глобальной переменной,
// теперь функция someFunc возвращает
// строку и ошибку.
func someFunc() (string, error) {
	//Создаем файл для хранения большой строки.
	f, err := os.Create("hugeString.txt")
	if err != nil {
		return "", err
	}
	//Записываем большую строку в файл.
	_, err = f.WriteString(createHugeString(1 << 10))
	if err != nil {
		return "", err
	}
	//Создаем слайс байт требуемой длины.
	res := make([]byte, 100)
	//Читаем только необходимое число байт с файла.
	_, err = f.Read(res)
	if err != nil {
		return "", err
	}

	//Не забываем закрыть файл.
	f.Close()
	//Возвращаем строку требуемой длины.
	return string(res), nil
}

func main() {
	justString, err := someFunc()
	if err != nil {
		log.Println(err)
	}

	//Какой-то код.
}
