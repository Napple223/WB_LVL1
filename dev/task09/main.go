package main

import "fmt"

//Разработать конвейер чисел.
//Даны два канала: в первый пишутся
//числа (x) из массива, во второй — результат
//операции x*2, после чего данные из второго
//канала должны выводиться в stdout.

//Пайплайн (конвейер) представляет собой последовательность этапов
//обработки данных, соединенных каналами, где
//каждый этап представляет собой группу горутин, выполняющих
//свою определенную функцию.
//т.е. этапы пайплайна это куски жесткой трубы,
//которые мы можем соединить в любом порядке с помощью каналов
//(гибких трубок).
//+ такого подхода:
//Гибкость настройки: мы можем тасовать и переиспользовать
//разные этапы пайплайна как угодно, так как все функции,
//кроме начальной и конечной, принимают в себя канал и возвращают канал.

func main() {
	//Слайс интов для обработки.
	input := []int{2, 4, 8, 10, 12, 16}

	//Функция - источник данных для нашего пайплайна.
	dataSourse := func(input []int) <-chan int {
		//Создаем канал передачи данных в пайплайн.
		outputCh := make(chan int)
		go func() {
			for _, v := range input {
				outputCh <- v
			}
			//Не забываем закрыть канал после отправки
			//всех данных, чтобы не получить дедлок.
			close(outputCh)
		}()
		return outputCh
	}
	//Этап пайплайна для возведения числа в степень 2ки.
	squaring := func(inputCh <-chan int) <-chan int {
		//Создаем канал для дальнейшей передачи данных.
		outputCh := make(chan int)
		go func() {
			for v := range inputCh {
				outputCh <- v * v
			}
			//Закрываем канал, чтобы избежать дедлока.
			close(outputCh)
		}()
		return outputCh
	}

	//Функция - потребитель данных, выходное звено
	//пайплайна. В нашем случае печать обработанных
	//данных в stdout.
	sink := func(inputCh <-chan int) {
		for v := range inputCh {
			fmt.Println(v)
		}
	}

	//Собираем пайплайн, где в качестве аргумента
	//функций передаем этапы обработки данных пайплайном.
	sink(squaring(dataSourse(input)))
}
